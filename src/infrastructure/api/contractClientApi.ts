/**
 * DFMS API
 * DFMS node HTTP API. [Reference implementation in GO](https://github.com/proximax-storage/go-xpx-dfms-api-http) [API definition](https://github.com/proximax-storage/go-xpx-dfms-api)  API does not tries to follow idiomatic REST or other API patterns for reasons.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { ContractDTO } from '../model/contractDTO';
import { ErrorDTO } from '../model/errorDTO';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://127.0.0.1/api/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ContractClientApiApiKeys {
}

export class ContractClientApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ContractClientApiApiKeys, value: string) {
        (this.authentications as any)[ContractClientApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Creates subscription for Drive Contract updates/corrections of any contract from the network by ID.
     * @summary Ammendments subscriptio
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     */
    public async ammends (arg1: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ContractDTO>;  }> {
        const localVarPath = this.basePath + '/contract/ammends';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling ammends.');
        }

        if (arg1 !== undefined) {
            localVarQueryParameters['arg'] = ObjectSerializer.serialize(arg1, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ContractDTO>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ContractDTO>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Compose synchronously announces invites to the Network with current node as an owner and tries to find members which agrees on specified parameters and options. It does not guarantee success on resolving members. On success persists contract locally and gives ability to use DriveFS.
     * @summary Creates new Drive contract
     * @param arg1 Total Drive space in MB. NOTE - Actual parameter name is \&#39;arg\&#39;
     * @param arg2 Total Drive duration in blocks. Avg block time - 15 seconds. NOTE - Actual parameter name is \&#39;arg\&#39;
     * @param replicas Desired amount of full data replicas for a new Drive. Defaults to 3.
     * @param minReplicas Minimum amount of requires full data replicas for a new Drive. Defaults to 3.
     * @param billingPrice Payment amount for one billing period. Defaults to required space * replicas
     * @param billingPeriod Period of time after which replicators receieve payment. Defaults to 172800 ~ 1 month. Example - if duration is one year and billing period is one month, then replicators will receive payouts 12 times every month.
     * @param percentApprovers Amount of replicators needed in percents to approve Drive Contract multisignature transactions. Defaults to 66.
     */
    public async compose (arg1: number, arg2: number, replicas?: number, minReplicas?: number, billingPrice?: number, billingPeriod?: number, percentApprovers?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContractDTO;  }> {
        const localVarPath = this.basePath + '/contract/compose';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling compose.');
        }

        // verify required parameter 'arg2' is not null or undefined
        if (arg2 === null || arg2 === undefined) {
            throw new Error('Required parameter arg2 was null or undefined when calling compose.');
        }

        if (arg1 !== undefined && arg2 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "number"), ObjectSerializer.serialize(arg2, "number")];
        }

        if (replicas !== undefined) {
            localVarQueryParameters['replicas'] = ObjectSerializer.serialize(replicas, "number");
        }

        if (minReplicas !== undefined) {
            localVarQueryParameters['min-replicas'] = ObjectSerializer.serialize(minReplicas, "number");
        }

        if (billingPrice !== undefined) {
            localVarQueryParameters['billing-price'] = ObjectSerializer.serialize(billingPrice, "number");
        }

        if (billingPeriod !== undefined) {
            localVarQueryParameters['billing-period'] = ObjectSerializer.serialize(billingPeriod, "number");
        }

        if (percentApprovers !== undefined) {
            localVarQueryParameters['percent-approvers'] = ObjectSerializer.serialize(percentApprovers, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContractDTO;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ContractDTO");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Searches for Drive Contract information over the network.
     * @summary Get Drive contract infromation
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     */
    public async getContract (arg1: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContractDTO;  }> {
        const localVarPath = this.basePath + '/contract/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling getContract.');
        }

        if (arg1 !== undefined) {
            localVarQueryParameters['arg'] = ObjectSerializer.serialize(arg1, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContractDTO;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body.Contract, "ContractDTO");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Lists all the contracts in which Node participates as an owner or a member
     * @summary List Drive contracts node aware of
     */
    public async ls (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ContractDTO>;  }> {
        const localVarPath = this.basePath + '/contract/ls';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ContractDTO>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body.Ids.map(id => { return {drive: id}}), "Array<ContractDTO>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
