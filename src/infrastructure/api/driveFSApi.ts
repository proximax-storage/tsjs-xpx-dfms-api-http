/**
 * DFMS API
 * DFMS node HTTP API. [Reference implementation in GO](https://github.com/proximax-storage/go-xpx-dfms-api-http) [API definition](https://github.com/proximax-storage/go-xpx-dfms-api)  API does not tries to follow idiomatic REST or other API patterns for reasons.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { ErrorDTO } from '../model/errorDTO';
import { InlineResponse200 } from '../model/inlineResponse200';
import { StatDTO } from '../model/statDTO';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';
import { Transform, Readable, PassThrough } from 'stream';

let defaultBasePath = 'https://127.0.0.1/api/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DriveFSApiApiKeys {
}

export class DriveFSApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: DriveFSApiApiKeys, value: string) {
        (this.authentications as any)[DriveFSApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Sends file or directory to remote node which adds it to the path of the contract
     * @summary Add file
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     * @param arg3 The destination path.
     * @param flush To immediately send data to replicators
     */
    public async driveAdd (arg1: string, arg3: string, flush?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/drive/add';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = (options as any).formData;

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveAdd.');
        }

        // verify required parameter 'arg3' is not null or undefined
        if (arg3 === null || arg3 === undefined) {
            throw new Error('Required parameter arg3 was null or undefined when calling driveAdd.');
        }

        if (arg1 !== undefined && arg3 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "string"), ObjectSerializer.serialize(arg3, "string")];
        }

        if (flush !== undefined) {
            localVarQueryParameters['flush'] = ObjectSerializer.serialize(flush, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: InlineResponse200;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Copy copies file or directory from the givens source path to the given destination path It does not makes the full copy of the file or directory, it just copies the reference
     * @summary Copy file
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     * @param arg2 The source path of the file in Drive.
     * @param arg3 The destination path.
     * @param flush To immediately send data to replicators
     */
    public async driveCp (arg1: string, arg2: string, arg3: string, flush?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/drive/cp';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveCp.');
        }

        // verify required parameter 'arg2' is not null or undefined
        if (arg2 === null || arg2 === undefined) {
            throw new Error('Required parameter arg2 was null or undefined when calling driveCp.');
        }

        // verify required parameter 'arg3' is not null or undefined
        if (arg3 === null || arg3 === undefined) {
            throw new Error('Required parameter arg3 was null or undefined when calling driveCp.');
        }

        if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "string"), ObjectSerializer.serialize(arg2, "string"), ObjectSerializer.serialize(arg3, "string")];
        }

        if (flush !== undefined) {
            localVarQueryParameters['flush'] = ObjectSerializer.serialize(flush, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Flush pushes state of the local Drive to all replicators
     * @summary Flush drive
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     */
    public async driveFlush (arg1: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/drive/flush';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveFlush.');
        }

        if (arg1 !== undefined) {
            localVarQueryParameters['arg'] = ObjectSerializer.serialize(arg1, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Sends file or directory to remote node which adds it to the path of the contract
     * @summary Get file
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     * @param arg2 The source path of the file in Drive.
     * @param flush To immediately send data to replicators
     */
    public async driveGet (arg1: string, arg2: string, flush?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/drive/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['text/plain', 'application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveGet.');
        }

        // verify required parameter 'arg2' is not null or undefined
        if (arg2 === null || arg2 === undefined) {
            throw new Error('Required parameter arg2 was null or undefined when calling driveGet.');
        }

        if (arg1 !== undefined && arg2 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "string"), ObjectSerializer.serialize(arg2, "string")];
        }

        if (flush !== undefined) {
            localVarQueryParameters['flush'] = ObjectSerializer.serialize(flush, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }

    /**
     * Sends file or directory to remote node which adds it to the path of the contract
     * @summary Get file
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     * @param arg2 The source path of the file in Drive.
     * @param flush To immediately send data to replicators
     */
    public async driveGetAsStream (arg1: string, arg2: string, flush?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Readable;  }> {
        const localVarPath = this.basePath + '/drive/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['text/plain', 'application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveGet.');
        }

        // verify required parameter 'arg2' is not null or undefined
        if (arg2 === null || arg2 === undefined) {
            throw new Error('Required parameter arg2 was null or undefined when calling driveGet.');
        }

        if (arg1 !== undefined && arg2 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "string"), ObjectSerializer.serialize(arg2, "string")];
        }

        if (flush !== undefined) {
            localVarQueryParameters['flush'] = ObjectSerializer.serialize(flush, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
/* EXAMPLE - streams + progress
            var fs = require('fs');
            var request = require('request');
            var progress = require('request-progress');

            // The options argument is optional so you can omit it
            progress(request('https://az412801.vo.msecnd.net/vhd/VMBuild_20141027/VirtualBox/IE11/Windows/IE11.Win8.1.For.Windows.VirtualBox.zip'), {
                // throttle: 2000,                    // Throttle the progress event to 2000ms, defaults to 1000ms
                // delay: 1000,                       // Only start to emit after 1000ms delay, defaults to 0ms
                // lengthHeader: 'x-transfer-length'  // Length header to use, defaults to content-length
            })
            .on('progress', function (state) {
                // The state is an object that looks like this:
                // {
                //     percent: 0.5,               // Overall percent (between 0 to 1)
                //     speed: 554732,              // The download speed in bytes/sec
                //     size: {
                //         total: 90044871,        // The total payload size in bytes
                //         transferred: 27610959   // The transferred payload size in bytes
                //     },
                //     time: {
                //         elapsed: 36.235,        // The total elapsed seconds since the start (3 decimals)
                //         remaining: 81.403       // The remaining seconds to finish (3 decimals)
                //     }
                // }
                console.log('progress', state);
            })
            .on('error', function (err) {
                // Do something with err
            })
            .on('end', function () {
                // Do something after request finishes
            })
            .pipe(fs.createWriteStream('IE11.Win8.1.For.Windows.VirtualBox.zip'));
*/
            // simple implementation of read/write identity stream using transform stream doing nothing
            //const readWriteStreamBody = new Transform()
            //readWriteStreamBody._transform = function (chunk,encoding,done)
            //{
            //   this.push(chunk)
            //    done()
            //}
            // well, it is actually built-in node:
            const readWriteStreamBody = new PassThrough();

            return new Promise<{ response: http.IncomingMessage; body: Readable;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions)
                .on('error', (error) => {
                    reject(error);
                }).on('finish', () => {
                    console.log("reading response finished");
                }).pipe(readWriteStreamBody);
                resolve({ response: undefined as any, body: readWriteStreamBody });;
            });
        });
    }
    /**
     * Ls returns information about the files and directories under the given path
     * @summary List files
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     * @param arg2 The source path of the file in Drive.
     */
    public async driveLs (arg1: string, arg2: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<StatDTO>;  }> {
        const localVarPath = this.basePath + '/drive/ls';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveLs.');
        }

        // verify required parameter 'arg2' is not null or undefined
        if (arg2 === null || arg2 === undefined) {
            throw new Error('Required parameter arg2 was null or undefined when calling driveLs.');
        }

        if (arg1 !== undefined && arg2 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "string"), ObjectSerializer.serialize(arg2, "string")];
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<StatDTO>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body.List, "Array<StatDTO>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * MakeDir creates new directory on the given path
     * @summary Make directory
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     * @param arg2 The source path of the file in Drive.
     * @param flush To immediately send data to replicators
     */
    public async driveMkdir (arg1: string, arg2: string, flush?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/drive/mkdir';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveMkdir.');
        }

        // verify required parameter 'arg2' is not null or undefined
        if (arg2 === null || arg2 === undefined) {
            throw new Error('Required parameter arg2 was null or undefined when calling driveMkdir.');
        }

        if (arg1 !== undefined && arg2 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "string"), ObjectSerializer.serialize(arg2, "string")];
        }

        if (flush !== undefined) {
            localVarQueryParameters['flush'] = ObjectSerializer.serialize(flush, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Move moves file or directory from the givens source path to the given destination path Use also to rename file or directory
     * @summary Move file
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     * @param arg2 The source path of the file in Drive.
     * @param arg3 The destination path.
     * @param flush To immediately send data to replicators
     */
    public async driveMv (arg1: string, arg2: string, arg3: string, flush?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/drive/mv';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveMv.');
        }

        // verify required parameter 'arg2' is not null or undefined
        if (arg2 === null || arg2 === undefined) {
            throw new Error('Required parameter arg2 was null or undefined when calling driveMv.');
        }

        // verify required parameter 'arg3' is not null or undefined
        if (arg3 === null || arg3 === undefined) {
            throw new Error('Required parameter arg3 was null or undefined when calling driveMv.');
        }

        if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "string"), ObjectSerializer.serialize(arg2, "string"), ObjectSerializer.serialize(arg3, "string")];
        }

        if (flush !== undefined) {
            localVarQueryParameters['flush'] = ObjectSerializer.serialize(flush, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Remove removes the file or directory from the path
     * @summary Remove file
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     * @param arg2 The source path of the file in Drive.
     * @param flush To immediately send data to replicators
     * @param local Delete file from local disk only, but keep reference on it remotely
     */
    public async driveRm (arg1: string, arg2: string, flush?: boolean, local?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/drive/rm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveRm.');
        }

        // verify required parameter 'arg2' is not null or undefined
        if (arg2 === null || arg2 === undefined) {
            throw new Error('Required parameter arg2 was null or undefined when calling driveRm.');
        }

        if (arg1 !== undefined && arg2 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "string"), ObjectSerializer.serialize(arg2, "string")];
        }

        if (flush !== undefined) {
            localVarQueryParameters['flush'] = ObjectSerializer.serialize(flush, "boolean");
        }

        if (local !== undefined) {
            localVarQueryParameters['local'] = ObjectSerializer.serialize(local, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Stat returns information about the file or directory under the given path
     * @summary File information
     * @param arg1 [Cid](https://github.com/multiformats/cid) (version 1) - special content identifier. May represents either data or Drive.
     * @param arg2 The source path of the file in Drive.
     */
    public async driveStat (arg1: string, arg2: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: StatDTO;  }> {
        const localVarPath = this.basePath + '/drive/stat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'arg1' is not null or undefined
        if (arg1 === null || arg1 === undefined) {
            throw new Error('Required parameter arg1 was null or undefined when calling driveStat.');
        }

        // verify required parameter 'arg2' is not null or undefined
        if (arg2 === null || arg2 === undefined) {
            throw new Error('Required parameter arg2 was null or undefined when calling driveStat.');
        }

        if (arg1 !== undefined && arg2 !== undefined) {
            localVarQueryParameters['arg'] =  [ObjectSerializer.serialize(arg1, "string"), ObjectSerializer.serialize(arg2, "string")];
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            qsStringifyOptions: {arrayFormat: 'repeat'}
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: StatDTO;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body.Stat, "StatDTO");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
