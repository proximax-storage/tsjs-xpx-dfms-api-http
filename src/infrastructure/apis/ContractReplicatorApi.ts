/* tslint:disable */
/* eslint-disable */
/**
 * DFMS API
 * DFMS node HTTP API. [Reference implementation in GO](https://github.com/proximax-storage/go-xpx-dfms-api-http) [API definition](https://github.com/proximax-storage/go-xpx-dfms-api)  API does not tries to follow idiomatic REST or other API patterns for reasons.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    CidListWrap,
    CidListWrapFromJSON,
    CidListWrapToJSON,
    ContractWrap,
    ContractWrapFromJSON,
    ContractWrapToJSON,
    ErrResult,
    ErrResultFromJSON,
    ErrResultToJSON,
    InviteWrap,
    InviteWrapFromJSON,
    InviteWrapToJSON,
    VerifyResult,
    VerifyResultFromJSON,
    VerifyResultToJSON,
} from '../models';

import { AbortController } from 'abort-controller';

export interface AcceptRequest {
    argDrive: string;
}
// same ifcs already exported by ContractClientApi - comment it out here and import it instead
import {
    AmmendsRequest,
    ComposeRequest,
    FinishRequest,
    GetContractRequest,
    VerifyRequest
} from './';
import { Observable } from 'rxjs';

/*
export interface AmmendsRequest {
    argDrive: string;
}

export interface ComposeRequest {
    argSpace: number;
    argDuration: string;
    replicas?: number;
    minReplicators?: number;
    subscriptionPrice?: number;
    numberSubscriptionPeriods?: number;
    percentApprovers?: number;
    privateKey?: string;
}

export interface FinishRequest {
    argDrive: string;
}

export interface GetContractRequest {
    argDrive: string;
}

export interface VerifyRequest {
    argDrive: string;
}
*/

/**
 *
 */
export class ContractReplicatorApi extends runtime.BaseAPI {

    /**
     * Accept joins contract by it\'s id. Can join only contracts awaiting new members.
     * Accept joins contract
     */
    async acceptRaw(requestParameters: AcceptRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.argDrive === null || requestParameters.argDrive === undefined) {
            throw new runtime.RequiredError('argDrive','Required parameter requestParameters.argDrive was null or undefined when calling accept.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        queryParameters['arg'] = requestParameters.argDrive;

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/contract/accept`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Accept joins contract by it\'s id. Can join only contracts awaiting new members.
     * Accept joins contract
     */
    async accept(requestParameters: AcceptRequest): Promise<void> {
        await this.acceptRaw(requestParameters);
    }

    /**
     * Establishes persitent connection and sends json value through it to the requester as long as new updates appear.
     * Show accepted contracts
     */
    async acceptedRaw(): Promise<{response: Response, abortController: AbortController}> {
    // async acceptedRaw(): Promise<runtime.ApiResponse<ContractWrap>> {
        const abortController = new AbortController();
        const signal = abortController.signal;

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/contract/accepted`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            signal: signal
        });

        return {response, abortController};
        // return new runtime.JSONApiResponse(response, (jsonValue) => ContractWrapFromJSON(jsonValue));
    }

    /**
     * Establishes persitent connection and sends json value through it to the requester as long as new updates appear.
     * Show accepted contracts
     */
    async accepted(): Promise<ContractWrap> {
        const response = await this.acceptedRaw();
        return new runtime.JSONApiResponse(response.response, (jsonValue) => ContractWrapFromJSON(jsonValue)).value();
        // return await response.value();
    }

    async acceptedAsStream(): Promise<ReadableStream<Uint8Array> | null> {
        const response = await this.acceptedRaw();
        return response.response.body;
    }

    /**
     * Creates subscription for Drive Contract updates/corrections of any contract from the network by ID.
     * Ammendments subscription
     */
    async ammendsRaw(requestParameters: AmmendsRequest): Promise<runtime.ApiResponse<ContractWrap>> {
        if (requestParameters.argDrive === null || requestParameters.argDrive === undefined) {
            throw new runtime.RequiredError('argDrive','Required parameter requestParameters.argDrive was null or undefined when calling ammends.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        queryParameters['arg'] = requestParameters.argDrive;

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/contract/ammends`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ContractWrapFromJSON(jsonValue));
    }

    /**
     * Creates subscription for Drive Contract updates/corrections of any contract from the network by ID.
     * Ammendments subscription
     */
    async ammends(requestParameters: AmmendsRequest): Promise<ContractWrap> {
        const response = await this.ammendsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Compose synchronously announces invites to the Network with current node as an owner and tries to find members which agrees on specified parameters and options. It does not guarantee success on resolving members. On success persists contract locally and gives ability to use DriveFS.
     * Creates new Drive contract
     */
    async composeRaw(requestParameters: ComposeRequest): Promise<runtime.ApiResponse<ContractWrap>> {
        if (requestParameters.argSpace === null || requestParameters.argSpace === undefined) {
            throw new runtime.RequiredError('argSpace','Required parameter requestParameters.argSpace was null or undefined when calling compose.');
        }

        if (requestParameters.argDuration === null || requestParameters.argDuration === undefined) {
            throw new runtime.RequiredError('argDuration','Required parameter requestParameters.argDuration was null or undefined when calling compose.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        queryParameters['arg'] = [ requestParameters.argSpace, requestParameters.argDuration ];

        if (requestParameters.replicas !== undefined) {
            queryParameters['replicas'] = requestParameters.replicas;
        }

        if (requestParameters.minReplicators !== undefined) {
            queryParameters['min-replicators'] = requestParameters.minReplicators;
        }

        if (requestParameters.subscriptionPrice !== undefined) {
            queryParameters['subscription-price'] = requestParameters.subscriptionPrice;
        }

        if (requestParameters.numberSubscriptionPeriods !== undefined) {
            queryParameters['number-subscription-periods'] = requestParameters.numberSubscriptionPeriods;
        }

        if (requestParameters.percentApprovers !== undefined) {
            queryParameters['percent-approvers'] = requestParameters.percentApprovers;
        }

        if (requestParameters.privateKey !== undefined) {
            queryParameters['private-key'] = requestParameters.privateKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/contract/compose`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ContractWrapFromJSON(jsonValue));
    }

    /**
     * Compose synchronously announces invites to the Network with current node as an owner and tries to find members which agrees on specified parameters and options. It does not guarantee success on resolving members. On success persists contract locally and gives ability to use DriveFS.
     * Creates new Drive contract
     */
    async compose(requestParameters: ComposeRequest): Promise<ContractWrap> {
        const response = await this.composeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Finish contract.
     * Finish contract
     */
    async finishRaw(requestParameters: FinishRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.argDrive === null || requestParameters.argDrive === undefined) {
            throw new runtime.RequiredError('argDrive','Required parameter requestParameters.argDrive was null or undefined when calling finish.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        queryParameters['arg'] = requestParameters.argDrive;

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/contract/finish`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Finish contract.
     * Finish contract
     */
    async finish(requestParameters: FinishRequest): Promise<void> {
        await this.finishRaw(requestParameters);
    }

    /**
     * Searches for Drive Contract information over the network.
     * Get Drive contract infromation
     */
    async getContractRaw(requestParameters: GetContractRequest): Promise<runtime.ApiResponse<ContractWrap>> {
        if (requestParameters.argDrive === null || requestParameters.argDrive === undefined) {
            throw new runtime.RequiredError('argDrive','Required parameter requestParameters.argDrive was null or undefined when calling getContract.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        queryParameters['arg'] = requestParameters.argDrive;

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/contract/get`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ContractWrapFromJSON(jsonValue));
    }

    /**
     * Searches for Drive Contract information over the network.
     * Get Drive contract infromation
     */
    async getContract(requestParameters: GetContractRequest): Promise<ContractWrap> {
        const response = await this.getContractRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates subscription for new contract invitations. Main use case is to have external contract acceptance logic.
     * Subscribe to new contracts
     */
    async invitesRaw(): Promise<{response: Response, abortController: AbortController}> {
    // async invitesRaw(): Promise<runtime.ApiResponse<InviteWrap>> {

        const abortController = new AbortController();
        const signal = abortController.signal;

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/contract/invites`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            signal: signal
        });

        return {response, abortController};
        // return new runtime.JSONApiResponse(response, (jsonValue) => InviteWrapFromJSON(jsonValue));
    }

    /**
     * Creates subscription for new contract invitations. Main use case is to have external contract acceptance logic.
     * Subscribe to new contracts
     */
    async invites(): Promise<InviteWrap> {
        const response = await this.invitesRaw();
        return new runtime.JSONApiResponse(response.response, (jsonValue) => InviteWrapFromJSON(jsonValue)).value();
        // return await response.value();
    }

    async invitesAsStream(): Promise<ReadableStream<Uint8Array> | null> {
        const response = await this.invitesRaw();
        return response.response.body;
    }

    /**
     * Lists all the contracts in which Node participates as an owner or a member
     * List Drive contracts node aware of
     */
    async lsRaw(): Promise<runtime.ApiResponse<CidListWrap>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/contract/ls`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CidListWrapFromJSON(jsonValue));
    }

    /**
     * Lists all the contracts in which Node participates as an owner or a member
     * List Drive contracts node aware of
     */
    async ls(): Promise<CidListWrap> {
        const response = await this.lsRaw();
        return await response.value();
    }

    /**
     * Initiates verification round between replicators.
     * Contract verify
     */
    async verifyRaw(requestParameters: VerifyRequest): Promise<runtime.ApiResponse<Array<VerifyResult>>> {
        if (requestParameters.argDrive === null || requestParameters.argDrive === undefined) {
            throw new runtime.RequiredError('argDrive','Required parameter requestParameters.argDrive was null or undefined when calling verify.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        queryParameters['arg'] = requestParameters.argDrive;

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/contract/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VerifyResultFromJSON));
    }

    /**
     * Initiates verification round between replicators.
     * Contract verify
     */
    async verify(requestParameters: VerifyRequest): Promise<Array<VerifyResult>> {
        const response = await this.verifyRaw(requestParameters);
        return await response.value();
    }

}
